# 1. Study
> [!INFO]
> 김영한 실전 자바 - 고급 1편, 섹션5 스레드제어와 생명 주기

### 1) Thread Interrupt 
특정 스레드의 작업을 중간에 중단하려면 어떻게 해야할까?

1) 가장 쉬운 방법 - 변수 사용
	- 문제점: `main` 스레드가 `runFlag=false`를 통해 작업 중단을 지시해도, work 스레드가 즉각 반응하지 않는다. 작업 중단 지시 2초 정도 이후에 자원을 정리하고 작업을 종료한다.
	- work 스레드는 `sleep(3000)` 을 통해 3초간 잠들어 있다.  3초간의 잠이 깬 다음에 `while(runFlag)` 코드를 실행해야, `runFlag` 를 확인하고 작업을 중단할 수 있다.
	- 어떻게 하면 `sleep()`처럼 스레드가 대기하는 상태에서 스레드를 깨우고, 작업도 빨리 종료할 수 있을까?
2) 인터럽트 사용
	- `WAITING` , `TIMED_WAITING` 같은 대기 상태의 스레드를 직접 깨워서, 작동하는 `RUNNABLE` 상태로 만들 수 있다.
	- 특정 스레드의 인스턴스에 `interrupt()` 메서드를 호출하면, 해당 스레드에 인터럽트가 발생한다.
	- 참고로 `interrupt()` 를 호출했다고 해서 즉각 `InterruptedException` 이 발생하는 것은 아니다. 오직 `sleep()` 처럼 `InterruptedException` 을 던지는 메서드를 호출 하거나 또는 호출 중일 때 예외가 발생한다.
	- 인터럽트가 적용되고, 인터럽트 예외가 발생하면, 해당 스레드는 실행 가능 상태가 되고, 인터럽트 발생 상태도 정상으로 돌아온다.
3) while에서 인터럽트 상태를 확인하는 경우 (`isInterrupted()`)
	- 문제점: `work` 스레드의 인터럽트 상태가 `true` 로 계속 유지된다는 점이다. 앞서 인터럽트 예외가 터진 경우 스레드의 인터럽트 상태는 `false` 가 된다. 반면에 `isInterrupted()` 메서드는 인터럽트의 상태를 변경하지 않는다. 단순히 인터럽트의 상태를 확인만 한다.
	- 자바에서 인터럽트 예외가 한 번 발생하면, 스레드의 인터럽트 상태를 다시 정상( `false` )으로 돌리는 것은 이런 이유 때문이다. 스레드의 인터럽트 상태를 정상으로 돌리지 않으면 이후에도 계속 인터럽트가 발생하게 된다. 인터럽트의 목적을 달성하면 인터럽트 상태를 다시 정상으로 돌려두어야 한다.
4) Thread.interrupted()
	- 스레드가 인터럽트 상태라면 `true` 를 반환하고, 해당 스레드의 인터럽트 상태를 `false` 로 변경한다.
	- 스레드가 인터럽트 상태가 아니라면 false 를 반환하고, 해당 스레드의 인터럽트 상태를 변경하지 않는다